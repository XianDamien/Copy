const k={learningSteps:"1 10",relearningSteps:"10",dailyNewCardsLimit:20,dailyReviewLimit:200,enableTraditionalLearningSteps:!1},F={requestRetention:.9,maximumInterval:36500,easyBonus:1.3,hardFactor:1.2,enableShortTerm:!1},p="userSettings";async function T(){try{const e=(await chrome.storage.sync.get(p))[p];return{...k,...e}}catch(r){return console.error("Failed to load user settings:",r),k}}async function P(r){try{const a={...await T(),...r};await chrome.storage.sync.set({[p]:a}),console.log("User settings saved successfully:",a)}catch(e){throw console.error("Failed to save user settings:",e),new Error("Failed to save settings")}}function M(r){const e=a=>{if(a[p]){const t=a[p].newValue;r(t)}};chrome.storage.onChanged.addListener(e)}function I(r){return r.split(" ").map(e=>parseInt(e.trim(),10)).filter(e=>!isNaN(e)&&e>0)}function O(r){const e=[];if(r.learningSteps!==void 0&&I(r.learningSteps).length===0&&e.push("Learning steps must contain at least one valid number"),r.relearningSteps!==void 0&&I(r.relearningSteps).length===0&&e.push("Relearning steps must contain at least one valid number"),r.dailyNewCardsLimit!==void 0&&(r.dailyNewCardsLimit<0||r.dailyNewCardsLimit>1e3)&&e.push("Daily new cards limit must be between 0 and 1000"),r.dailyReviewLimit!==void 0&&(r.dailyReviewLimit<0||r.dailyReviewLimit>1e4)&&e.push("Daily review limit must be between 0 and 10000"),r.geminiApiKey!==void 0&&r.geminiApiKey.trim()){const a=r.geminiApiKey.trim();!a.startsWith("AIza")&&!a.startsWith("AIza")&&e.push('Gemini API key must start with "AIza"'),a.length<35&&e.push("Gemini API key appears to be too short")}return e}const ee=Object.freeze(Object.defineProperty({__proto__:null,addSettingsChangeListener:M,getSettings:T,parseLearningSteps:I,saveSettings:P,validateSettings:O},Symbol.toStringTag,{value:"Module"})),A=(r,e)=>e.some(a=>r instanceof a);let L,x;function $(){return L||(L=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function _(){return x||(x=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const m=new WeakMap,b=new WeakMap,y=new WeakMap;function q(r){const e=new Promise((a,t)=>{const s=()=>{r.removeEventListener("success",n),r.removeEventListener("error",i)},n=()=>{a(f(r.result)),s()},i=()=>{t(r.error),s()};r.addEventListener("success",n),r.addEventListener("error",i)});return y.set(e,r),e}function V(r){if(m.has(r))return;const e=new Promise((a,t)=>{const s=()=>{r.removeEventListener("complete",n),r.removeEventListener("error",i),r.removeEventListener("abort",i)},n=()=>{a(),s()},i=()=>{t(r.error||new DOMException("AbortError","AbortError")),s()};r.addEventListener("complete",n),r.addEventListener("error",i),r.addEventListener("abort",i)});m.set(r,e)}let S={get(r,e,a){if(r instanceof IDBTransaction){if(e==="done")return m.get(r);if(e==="store")return a.objectStoreNames[1]?void 0:a.objectStore(a.objectStoreNames[0])}return f(r[e])},set(r,e,a){return r[e]=a,!0},has(r,e){return r instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in r}};function B(r){S=r(S)}function K(r){return _().includes(r)?function(...e){return r.apply(v(this),e),f(this.request)}:function(...e){return f(r.apply(v(this),e))}}function U(r){return typeof r=="function"?K(r):(r instanceof IDBTransaction&&V(r),A(r,$())?new Proxy(r,S):r)}function f(r){if(r instanceof IDBRequest)return q(r);if(b.has(r))return b.get(r);const e=U(r);return e!==r&&(b.set(r,e),y.set(e,r)),e}const v=r=>y.get(r);function W(r,e,{blocked:a,upgrade:t,blocking:s,terminated:n}={}){const i=indexedDB.open(r,e),d=f(i);return t&&i.addEventListener("upgradeneeded",o=>{t(f(i.result),o.oldVersion,o.newVersion,f(i.transaction),o)}),a&&i.addEventListener("blocked",o=>a(o.oldVersion,o.newVersion,o)),d.then(o=>{n&&o.addEventListener("close",()=>n()),s&&o.addEventListener("versionchange",c=>s(c.oldVersion,c.newVersion,c))}).catch(()=>{}),d}const z=["get","getKey","getAll","getAllKeys","count"],G=["put","add","delete","clear"],D=new Map;function N(r,e){if(!(r instanceof IDBDatabase&&!(e in r)&&typeof e=="string"))return;if(D.get(e))return D.get(e);const a=e.replace(/FromIndex$/,""),t=e!==a,s=G.includes(a);if(!(a in(t?IDBIndex:IDBObjectStore).prototype)||!(s||z.includes(a)))return;const n=async function(i,...d){const o=this.transaction(i,s?"readwrite":"readonly");let c=o.store;return t&&(c=c.index(d.shift())),(await Promise.all([c[a](...d),s&&o.done]))[0]};return D.set(e,n),n}B(r=>({...r,get:(e,a,t)=>N(e,a)||r.get(e,a,t),has:(e,a)=>!!N(e,a)||r.has(e,a)}));const Y=["continue","continuePrimaryKey","advance"],E={},C=new WeakMap,R=new WeakMap,H={get(r,e){if(!Y.includes(e))return r[e];let a=E[e];return a||(a=E[e]=function(...t){C.set(this,R.get(this)[e](...t))}),a}};async function*J(...r){let e=this;if(e instanceof IDBCursor||(e=await e.openCursor(...r)),!e)return;e=e;const a=new Proxy(e,H);for(R.set(a,e),y.set(a,v(e));e;)yield a,e=await(C.get(a)||e.continue()),C.delete(a)}function j(r,e){return e===Symbol.asyncIterator&&A(r,[IDBIndex,IDBObjectStore,IDBCursor])||e==="iterate"&&A(r,[IDBIndex,IDBObjectStore])}B(r=>({...r,get(e,a,t){return j(e,a)?J:r.get(e,a,t)},has(e,a){return j(e,a)||r.has(e,a)}}));const Q="LanGearDB",X=3;class Z{constructor(){this.db=null}async initDatabase(){try{this.db=await W(Q,X,{upgrade(e,a,t,s){if(console.log(`Upgrading database from version ${a} to ${t}`),e.objectStoreNames.contains("decks")||e.createObjectStore("decks",{keyPath:"id",autoIncrement:!0}).createIndex("name","name",{unique:!1}),!e.objectStoreNames.contains("notes")){const n=e.createObjectStore("notes",{keyPath:"id",autoIncrement:!0});n.createIndex("deckId","deckId",{unique:!1}),n.createIndex("noteType","noteType",{unique:!1}),n.createIndex("tags","tags",{unique:!1,multiEntry:!0})}if(e.objectStoreNames.contains("cards")){if(a<2){const n=s.objectStore("cards");n.indexNames.contains("deckId")||n.createIndex("deckId","deckId",{unique:!1}),n.indexNames.contains("deckId-due")||n.createIndex("deckId-due",["deckId","due"],{unique:!1})}}else{const n=e.createObjectStore("cards",{keyPath:"id",autoIncrement:!0});n.createIndex("noteId","noteId",{unique:!1}),n.createIndex("deckId","deckId",{unique:!1}),n.createIndex("due","due",{unique:!1}),n.createIndex("state","state",{unique:!1}),n.createIndex("deckId-due",["deckId","due"],{unique:!1})}if(a<3&&s.objectStore("cards").openCursor().then(function i(d){if(d){const o=d.value;o.learningStep===void 0&&(o.learningStep=0,d.update(o)),d.continue().then(i)}}),!e.objectStoreNames.contains("reviewLogs")){const n=e.createObjectStore("reviewLogs",{keyPath:"id",autoIncrement:!0});n.createIndex("cardId","cardId",{unique:!1}),n.createIndex("reviewTime","reviewTime",{unique:!1})}e.objectStoreNames.contains("audioStore")||e.createObjectStore("audioStore",{keyPath:"id"}).createIndex("createdAt","createdAt",{unique:!1})}}),console.log("Database initialized successfully")}catch(e){throw console.error("Failed to initialize database:",e),e}}ensureDatabase(){if(!this.db)throw new Error("Database not initialized. Call initDatabase() first.");return this.db}async createDeck(e){const a=this.ensureDatabase(),t=new Date,s={...e,fsrsConfig:{...F,...e.fsrsConfig},createdAt:t,updatedAt:t},n=await a.add("decks",s);return{...s,id:n}}async getAllDecks(){return(await this.ensureDatabase().getAll("decks")).map(t=>({...t,createdAt:typeof t.createdAt=="string"?new Date(t.createdAt):t.createdAt,updatedAt:typeof t.updatedAt=="string"?new Date(t.updatedAt):t.updatedAt}))}async getDeckById(e){const t=await this.ensureDatabase().get("decks",e);return t?{...t,createdAt:typeof t.createdAt=="string"?new Date(t.createdAt):t.createdAt,updatedAt:typeof t.updatedAt=="string"?new Date(t.updatedAt):t.updatedAt}:void 0}async updateDeck(e,a){const t=this.ensureDatabase(),s=await t.get("decks",e);if(!s)throw new Error(`Deck with id ${e} not found`);const n={...s,...a,updatedAt:new Date};return await t.put("decks",n),n}async deleteDeck(e){const t=this.ensureDatabase().transaction(["decks","notes","cards","reviewLogs"],"readwrite");if(!await t.objectStore("decks").get(e))throw new Error(`Deck with id ${e} not found`);const i=(await t.objectStore("notes").index("deckId").getAll(e)).map(d=>d.id);for(const d of i){const o=await t.objectStore("cards").index("noteId").getAll(d),c=o.map(u=>u.id);for(const u of c){const w=await t.objectStore("reviewLogs").index("cardId").getAll(u);for(const g of w)await t.objectStore("reviewLogs").delete(g.id)}for(const u of o)await t.objectStore("cards").delete(u.id);await t.objectStore("notes").delete(d)}await t.objectStore("decks").delete(e),await t.done}async createNote(e){const a=this.ensureDatabase(),t=new Date;try{const{id:s,createdAt:n,updatedAt:i,...d}=e,o={...d,createdAt:t,updatedAt:t};console.log("Creating note with clean data:",{...o,id:"[auto-generated]"});const c=await a.add("notes",o),u={...o,id:c};return console.log("Note created successfully with ID:",c),u}catch(s){throw console.error("Failed to create note:",s),s instanceof Error&&s.name==="ConstraintError"?new Error("Note creation failed: Duplicate key conflict. This may indicate database corruption or concurrent operations."):s}}async getNotesByDeckId(e){return(await this.ensureDatabase().getAllFromIndex("notes","deckId",e)).map(s=>this.convertDatesInNote(s))}async getNoteById(e){const t=await this.ensureDatabase().get("notes",e);return t?this.convertDatesInNote(t):void 0}async updateNote(e,a){const t=this.ensureDatabase(),s=await t.get("notes",e);if(!s)throw new Error(`Note with id ${e} not found`);const n={...s,...a,updatedAt:new Date};return await t.put("notes",n),n}async deleteNote(e){const t=(await this.ensureDatabase()).transaction(["notes","cards","reviewLogs"],"readwrite"),s=await t.objectStore("cards").index("noteId").getAll(e);for(const n of s){const i=await t.objectStore("reviewLogs").index("cardId").getAll(n.id);for(const d of i)await t.objectStore("reviewLogs").delete(d.id);await t.objectStore("cards").delete(n.id)}await t.objectStore("notes").delete(e),await t.done}async bulkCreateNotes(e){const t=(await this.ensureDatabase()).transaction("notes","readwrite"),s=t.objectStore("notes"),n=[];for(const i of e){const d=await s.add(i);n.push({...i,id:d})}return await t.done,n}async createCardsForNote(e){const a=this.ensureDatabase(),t=[],s=new Date;switch(console.log("Creating cards for note:",e.id,"type:",e.noteType),e.noteType){case"CtoE":t.push({noteId:e.id,deckId:e.deckId,cardType:"CtoE",state:"New",due:s,stability:0,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,learningStep:0,createdAt:s,updatedAt:s});break;case"Retranslate":t.push({noteId:e.id,deckId:e.deckId,cardType:"Retranslate",state:"New",due:s,stability:0,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,learningStep:0,createdAt:s,updatedAt:s});break;case"audio_subtitle":const n=e.fields.audio_subtitle;if(!n)throw new Error("audio_subtitle note missing required fields");t.push({noteId:e.id,deckId:e.deckId,cardType:"forward",state:"New",due:s,stability:2.5,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,learningStep:0,audioId:n.audioId,createdAt:s,updatedAt:s}),n.translatedText.trim()!==n.originalText.trim()&&t.push({noteId:e.id,deckId:e.deckId,cardType:"reverse",state:"New",due:s,stability:2.5,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,learningStep:0,audioId:n.audioId,createdAt:s,updatedAt:s}),t.push({noteId:e.id,deckId:e.deckId,cardType:"audio_comprehension",state:"New",due:s,stability:2.5,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,learningStep:0,audioId:n.audioId,createdAt:s,updatedAt:s});break;default:throw new Error(`Unsupported note type: ${e.noteType}`)}try{const n=[];for(const i of t){console.log("Adding card to database:",{...i,id:"[auto-generated]"});const d=await a.add("cards",i),o={...i,id:d};n.push(o),console.log("Card created successfully with ID:",d)}return console.log("All cards created successfully for note:",e.id,"total cards:",n.length),n}catch(n){throw console.error("Failed to create cards for note:",e.id,n),n instanceof Error&&n.name==="ConstraintError"?new Error(`Card creation failed for note ${e.id}: Auto-increment key conflict. This may indicate database corruption.`):n}}async getDueCards(e,a,t,s){const n=this.ensureDatabase(),i=new Date;let d;if(e){const u=n.transaction("cards","readonly").store.index("deckId-due"),w=IDBKeyRange.bound([e,new Date(0)],[e,i]);d=await u.getAll(w)}else d=await n.getAll("cards");const o=d.map(c=>this.convertDatesInCard(c)).filter(c=>c.due<=i);return o.sort((c,u)=>c.due.getTime()-u.due.getTime()),t!==void 0||s!==void 0?this.applyDailyLimits(o,t,s):a?o.slice(0,a):o}async applyDailyLimits(e,a,t){const s=await this.getTodayReviewCounts(),n=[];let i=0,d=0;for(const o of e){const c=o.state==="New",u=o.state==="Review"||o.state==="Learning"||o.state==="Relearning";if(c&&a!==void 0){if(s.newCards+i>=a)continue;i++}if(u&&t!==void 0){if(s.reviewCards+d>=t)continue;d++}n.push(o)}return n}async getTodayReviewCounts(){const e=this.ensureDatabase(),a=new Date,t=new Date(a.getFullYear(),a.getMonth(),a.getDate()),s=new Date(a.getFullYear(),a.getMonth(),a.getDate()+1),i=e.transaction("reviewLogs","readonly").store.index("reviewTime"),d=IDBKeyRange.bound(t,s,!1,!0),o=await i.getAll(d);let c=0,u=0;for(const w of o)w.stateBefore==="New"?c++:u++;return{newCards:c,reviewCards:u}}async getCardsByDeckId(e){return(await this.ensureDatabase().getAllFromIndex("cards","deckId",e)).map(s=>this.convertDatesInCard(s))}async getCardById(e){const t=await this.ensureDatabase().get("cards",e);return t?this.convertDatesInCard(t):void 0}async updateCard(e,a){const t=this.ensureDatabase(),s=await this.getCardById(e);if(!s)throw new Error(`Card with id ${e} not found`);const n={...s,...a,updatedAt:new Date};return await t.put("cards",n),n}async resetCardProgress(e){const a=this.ensureDatabase(),t=await this.getCardById(e);if(!t)throw new Error(`Card with id ${e} not found`);const s={...t,state:"New",due:new Date,stability:0,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,lastReview:void 0,updatedAt:new Date};await a.put("cards",s);const n=a.transaction(["reviewLogs"],"readwrite"),d=n.objectStore("reviewLogs").index("cardId");for await(const o of d.iterate(e))await o.delete();await n.done}async resetCardsInDeck(e){const a=this.ensureDatabase();let t=0;try{const s=a.transaction(["cards","reviewLogs"],"readwrite"),n=s.objectStore("cards"),i=s.objectStore("reviewLogs");let d;e===null?d=await n.getAll():d=await n.index("deckId").getAll(e),console.log(`Resetting ${d.length} cards in deck ${e||"all decks"}`);for(const o of d){const c={...o,state:"New",due:new Date,stability:0,difficulty:0,elapsedDays:0,scheduledDays:0,reps:0,lapses:0,lastReview:void 0,updatedAt:new Date};await n.put(c),t++;const u=i.index("cardId");for await(const w of u.iterate(o.id))await w.delete()}return await s.done,console.log(`Successfully reset ${t} cards`),t}catch(s){throw console.error("Error resetting cards in deck:",s),new Error(`Failed to reset cards: ${s instanceof Error?s.message:"Unknown error"}`)}}async addReviewLog(e){const t=await this.ensureDatabase().add("reviewLogs",e);return{...e,id:t}}async getReviewLogsByCardId(e){return(await this.ensureDatabase().getAllFromIndex("reviewLogs","cardId",e)).map(s=>this.convertDatesInReviewLog(s))}async addAudioClip(e,a="audio/mp3",t){const s=this.ensureDatabase(),n=crypto.randomUUID(),i={id:n,audioData:e,mimeType:a,duration:t,createdAt:new Date};return await s.put("audioStore",i),n}async getAudioClip(e){const t=await this.ensureDatabase().get("audioStore",e);if(t)return{...t,createdAt:typeof t.createdAt=="string"?new Date(t.createdAt):t.createdAt}}async deleteAudioClip(e){await this.ensureDatabase().delete("audioStore",e)}async getAllAudioClips(){return(await this.ensureDatabase().getAll("audioStore")).map(t=>({...t,createdAt:typeof t.createdAt=="string"?new Date(t.createdAt):t.createdAt}))}async getDeckStatistics(e){const a=this.ensureDatabase(),t=await a.getAllFromIndex("notes","deckId",e),s=await a.getAllFromIndex("cards","deckId",e),n=t.map(l=>this.convertDatesInNote(l)),i=s.map(l=>this.convertDatesInCard(l)),d=n.length;let o=i.length,c=0,u=0,w=0,g=0;const h=new Date;for(const l of i){switch(l.state){case"New":c++;break;case"Learning":u++;break;case"Review":w++;break}l.due<=h&&g++}return{totalCards:o,newCards:c,learningCards:u,reviewCards:w,dueCards:g,totalNotes:d}}convertDatesInCard(e){return{...e,due:typeof e.due=="string"?new Date(e.due):e.due,createdAt:typeof e.createdAt=="string"?new Date(e.createdAt):e.createdAt,updatedAt:typeof e.updatedAt=="string"?new Date(e.updatedAt):e.updatedAt}}convertDatesInNote(e){return{...e,createdAt:typeof e.createdAt=="string"?new Date(e.createdAt):e.createdAt,updatedAt:typeof e.updatedAt=="string"?new Date(e.updatedAt):e.updatedAt}}convertDatesInReviewLog(e){return{...e,reviewTime:typeof e.reviewTime=="string"?new Date(e.reviewTime):e.reviewTime}}async validateDatabaseIntegrity(){const e=this.ensureDatabase(),a=[];let t=0;try{const s=await e.getAll("cards"),n=await e.getAll("notes"),i=new Set(n.map(l=>l.id)),d=s.filter(l=>!i.has(l.noteId));d.length>0&&(a.push(`Found ${d.length} orphaned cards without corresponding notes`),t+=d.length);const o=await e.getAll("reviewLogs"),c=new Set(s.map(l=>l.id)),u=o.filter(l=>!c.has(l.cardId));u.length>0&&(a.push(`Found ${u.length} orphaned review logs without corresponding cards`),t+=u.length);const w=await e.getAll("decks"),g=new Set(w.map(l=>l.id)),h=n.filter(l=>!g.has(l.deckId));return h.length>0&&(a.push(`Found ${h.length} orphaned notes without corresponding decks`),t+=h.length),console.log("Database integrity check completed:",{isValid:a.length===0,issues:a,orphanedRecords:t}),{isValid:a.length===0,issues:a,orphanedRecords:t}}catch(s){return console.error("Database integrity validation failed:",s),{isValid:!1,issues:[`Validation failed: ${s instanceof Error?s.message:"Unknown error"}`],orphanedRecords:0}}}async clearAllData(){const a=this.ensureDatabase().transaction(["decks","notes","cards","reviewLogs","audioStore"],"readwrite");await a.objectStore("reviewLogs").clear(),await a.objectStore("cards").clear(),await a.objectStore("notes").clear(),await a.objectStore("decks").clear(),await a.objectStore("audioStore").clear(),await a.done}close(){this.db&&(this.db.close(),this.db=null)}}const te=new Z;export{k as D,Z as a,F as b,M as c,te as d,ee as e,T as g,I as p,P as s,O as v};
