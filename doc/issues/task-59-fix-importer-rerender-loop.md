# Context
Filename: task-59-fix-importer-rerender-loop.md
Created On: 2024年12月19日
Created By: Claude 4 Sonnet AI
Associated Protocol: RIPER-5 + Multidimensional + Agent Protocol

# Task Description
修复 AudioSubtitleImporter 组件中的无限重渲染循环问题。控制台显示无休止的重复日志：
- `Received message: GET_USER_CONFIG`
- `Received message: GET_ALL_DECKS`
- `AudioSubtitleImporter loaded`

这个问题导致页面卡顿、CPU占用过高，影响用户体验。

# Project Overview
这是一个基于React的Chrome扩展项目，实现了音频+字幕批量制卡功能。AudioSubtitleImporter组件是核心导入组件，负责处理音频和字幕文件的上传、AI翻译、音频切分和卡片生成等功能。

---
*The following sections are maintained by the AI during protocol execution*
---

# Analysis (Populated by RESEARCH mode)
通过深入分析代码，发现问题根源在于 `src/main/components/import/AudioSubtitleImporter.tsx` 文件中的React钩子依赖管理不当：

1. **ApiClient实例化问题**: 第32行 `const apiClient = new ApiClient();` 在每次组件渲染时都会创建新的实例
2. **useCallback依赖链**: `loadApiKey` 和 `loadAvailableDecks` 函数依赖于 `apiClient`，每次渲染时都会重新创建
3. **useEffect触发**: 第320行的 `useEffect` 依赖于 `loadApiKey`，导致无限循环
4. **循环链条**: 组件渲染 → 新ApiClient → 新函数 → useEffect触发 → 状态更新 → 重新渲染

关键文件:
- `src/main/components/import/AudioSubtitleImporter.tsx` (问题源头)
- `src/shared/utils/api.ts` (ApiClient实现)
- `src/background/index.ts` (消息处理)

# Proposed Solution (Populated by INNOVATE mode)
解决方案是使用React的useMemo钩子稳定ApiClient实例：
- 将 `const apiClient = new ApiClient();` 改为 `const apiClient = React.useMemo(() => new ApiClient(), []);`
- 简化相关useCallback的依赖数组
- 确保ApiClient在组件生命周期内只创建一次

优点：
- 直接解决根本原因
- 最小化代码变更
- 符合React最佳实践
- 立即生效

# Implementation Plan (Generated by PLAN mode)
1. 打开 `src/main/components/import/AudioSubtitleImporter.tsx` 文件
2. 找到第32行的 `const apiClient = new ApiClient();`
3. 替换为 `const apiClient = React.useMemo(() => new ApiClient(), []);`
4. 调整 `loadApiKey` 函数的依赖数组，从 `[apiClient]` 改为 `[]`
5. 调整 `loadAvailableDecks` 函数的依赖数组，从 `[apiClient, selectedDeckId]` 改为 `[selectedDeckId]`
6. 验证修复效果：检查控制台日志是否停止无限滚动

# Execution Results (EXECUTE mode)

## 修改完成
已成功完成所有计划中的修改：

### 1. ApiClient实例化修复
✅ **文件**: `src/main/components/import/AudioSubtitleImporter.tsx` 第32行
```typescript
// 修改前
const apiClient = new ApiClient();

// 修改后  
const apiClient = React.useMemo(() => new ApiClient(), []);
```

### 2. loadApiKey依赖数组优化
✅ **文件**: `src/main/components/import/AudioSubtitleImporter.tsx` 第307行
```typescript
// 修改前
}, [apiClient]);

// 修改后
}, []);
```

### 3. loadAvailableDecks依赖数组优化
✅ **文件**: `src/main/components/import/AudioSubtitleImporter.tsx` 第325行
```typescript
// 修改前
}, [apiClient, selectedDeckId]);

// 修改后
}, [selectedDeckId]);
```

## 技术解决方案说明
1. **useMemo稳定化**: `React.useMemo(() => new ApiClient(), [])` 确保ApiClient实例在组件生命周期内保持不变
2. **依赖数组清理**: 移除了对不稳定ApiClient实例的依赖，消除了无限循环的触发源
3. **最小化影响**: 修改仅涉及3处代码，不影响组件的其他功能

## 预期效果
修复后，控制台中的无限日志循环应该停止：
- ✅ `Received message: GET_USER_CONFIG` 只在组件加载时出现一次
- ✅ `Received message: GET_ALL_DECKS` 只在组件加载时出现一次  
- ✅ `AudioSubtitleImporter loaded` 只在组件加载时出现一次
- ✅ 页面响应性恢复正常
- ✅ CPU使用率降低到正常水平

## 验证步骤
用户可通过以下步骤验证修复效果：
1. 启动应用程序
2. 打开浏览器开发者工具(F12) → Console标签
3. 导航到包含AudioSubtitleImporter组件的页面
4. 观察控制台日志，确认不再出现无限滚动的重复消息

修复已完成，建议用户立即测试验证效果。 