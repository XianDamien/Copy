[MODE: PLAN]

遵命。我将为您和执行者 Claude Sonnet 4 准备一份详尽、精准、可一步步执行的测试修复计划。这份计划将涵盖从重构测试设置到逐一修复失败的测试文件，再到最终验证的每一个环节。

这份计划将作为新的任务文档 `doc/issues/task-42-fix-review-tests.md`。

---

# **`task-42-fix-review-tests.md`**

## **Context**

*   **Filename**: `task-42-fix-review-tests.md`
*   **Created On**: [Current DateTime]
*   **Associated Protocol**: RIPER-5

## **Task Description**

此任务旨在修复在 Task 41 (任务驱动UI重构) 后完全失效的复习功能自动化测试套件。修复后的测试必须能够验证全新的“任务驱动模式”和兼容保留的“传统复习模式”，确保应用核心功能的稳定性和正确性。

## **Project Overview**

本次测试修复是 Task 41 重构的收尾工作，是保证项目长期健康发展的关键一步。一个可靠的自动化测试套件能让我们在未来迭代中充满信心，避免功能回退，是高质量软件交付的基石。

---
*The following sections are maintained by the AI during protocol execution*
---

## **Analysis (Populated by RESEARCH mode)**

1.  **失败根源**: 现有测试 (`review-refactor-phase2.test.tsx`, `review-inline-editing-phase3.test.tsx`) 仍然在寻找为旧UI设计的元素（如直接显示的答案、旧的“显示答案”按钮）。
2.  **流程不匹配**: 测试未适配新的“任务驱动”流程。在新流程中，应用首先渲染 `TaskDisplay` 和 `TranslationInput`，而不是直接渲染 `CardDisplay`。
3.  **超时与失败**: 由于找不到预期的旧元素，测试要么因“元素未找到”而立即失败，要么因等待超时而失败。
4.  **模拟失效**: `settingsService` 的模拟需要更新，以支持在两种学习模式之间切换，从而分别测试两种流程。

## **Implementation Plan (Generated by PLAN mode)**

此计划分为三个核心阶段，旨在系统性地修复测试，确保覆盖所有关键场景。

### **Phase 1: Test Suite Refactoring & Modernization**

**目标**: 重构现有测试文件，使其结构与新的双模式复习系统保持一致，并更新模拟（Mock）实现。

*   **Task 1.1: Refactor `review-refactor-phase2.test.tsx`**
    *   [ ] 打开 `src/tests/review-refactor-phase2.test.tsx`。
    *   [ ] 在文件顶部，创建两个独立的模拟设置。一个用于“任务驱动”模式 (`enableTraditionalLearningSteps: false`)，另一个用于“传统”模式 (`enableTraditionalLearningSteps: true`)。
    *   [ ] 将整个 `describe` 块重命名为 `describe('Review Component Tests', () => { ... })`。
    *   [ ] 在内部创建两个新的 `describe` 块：
        *   `describe('Task-Driven Mode', () => { ... })`
        *   `describe('Traditional Mode', () => { ... })`
    *   [ ] 在每个新的 `describe` 块内部使用 `beforeEach`，通过 `vi.mock` 为该块的测试配置相应的 `settingsService` 模拟。

*   **Task 1.2: Rename and Refactor `review-inline-editing-phase3.test.tsx`**
    *   [ ] 将文件名 `src/tests/review-inline-editing-phase3.test.tsx` 重命名为 `src/tests/review-sidepanel-editing.test.tsx`，以准确反映其新职责。
    *   [ ] 打开新文件，将其中的测试逻辑全部迁移到验证 `SidePanel` 内的 `RichTextEditor` 编辑和保存功能。移除所有与旧 `CardDisplay` 内联编辑相关的断言。

### **Phase 2: Implementing Task-Driven Mode Tests**

**目标**: 在 `review-refactor-phase2.test.tsx` 中，为全新的“任务驱动”流程编写健壮的测试用例。

*   **Task 2.1: Test Initial Render**
    *   [ ] 编写一个测试，验证在任务模式下，应用首次渲染时会正确显示 `TaskDisplay`（包含“请翻译以下内容：”）和 `TranslationInput` 组件。

*   **Task 2.2: Test Task Submission and Evaluation Flow**
    *   [ ] 编写一个测试，模拟以下完整流程：
        1.  在 `TranslationInput` 中输入文本。
        2.  点击“提交翻译”按钮。
        3.  使用 `waitFor` 验证 `EvaluationDisplay` 是否出现。
        4.  断言 `EvaluationDisplay` 中正确显示了原文、用户翻译和参考翻译。
        5.  断言 `SelfEvaluationControls`（“我做对了”、“我还需要练习”）已显示。

*   **Task 2.3: Test Self-Evaluation**
    *   [ ] 编写一个测试，在进入评估界面后，点击“我做对了”按钮，并验证 `mockApiClient.reviewCard` 被以 `'Good'` 参数调用。
    *   [ ] 编写另一个测试，点击“我还需要练习”按钮，并验证 `mockApiClient.reviewCard` 被以 `'Again'` 参数调用。

### **Phase 3: Adapting Traditional Mode & SidePanel Tests**

**目标**: 确保传统模式的功能依然完好，并验证新的 `SidePanel` 编辑功能。

*   **Task 3.1: Adapt Traditional Mode Tests**
    *   [ ] 在 `review-refactor-phase2.test.tsx` 的 `Traditional Mode` `describe` 块中。
    *   [ ] 迁移并改造旧的测试用例，确保它们在 `enableTraditionalLearningSteps: true` 的设置下能够通过。
    *   [ ] 验证初始渲染直接显示 `CardDisplay`。
    *   [ ] 验证点击“显示答案”按钮后，经典的四个评分按钮 (`'Again'`, `'Hard'`, `'Good'`, `'Easy'`) 会出现并正常工作。

*   **Task 3.2: Implement `SidePanel` Editing Tests**
    *   [ ] 在 `review-sidepanel-editing.test.tsx` 中。
    *   [ ] 编写测试，验证 `SidePanel` 打开后，`RichTextEditor` 能够被渲染。
    *   [ ] 编写测试，模拟在 `SidePanel` 的“学习笔记”编辑器中输入内容，并验证 `handleNoteFieldUpdate` 被调用，最终触发 `mockApiClient.updateNote` API调用。
    *   [ ] **(选做，如果时间允许)** 结合 `vi.useFakeTimers()` 测试笔记更新的防抖逻辑是否依然按预期工作。

### **Phase 4: Final Validation**

**目标**: 运行完整的测试套件，确保所有测试通过，并清理项目。

*   **Task 4.1: Full Test Suite Execution**
    *   [ ] 在项目根目录运行 `npm test`。
    *   [ ] 解决所有可能出现的失败或警告，直到所有测试 100% 通过。

*   **Task 4.2: Cleanup**
    *   [ ] 审查所有修改过的测试文件，移除被注释掉的、过时的或冗余的代码。
    *   [ ] 确保测试描述清晰、准确。

---

我将严格按照此计划顺序执行。首先是重构测试结构，然后为新功能编写测试，接着适配旧功能测试，最后进行全局验证。